{"ro": {"0": {"statement": "Structurile de control sunt:", "correct": [0, 1, 2], "answers": [{"id": "0", "answer": "Cuvinte cheie rezervate limbajului de programare care ne permit să efectuăm operații decizionale și repetitive în cod"}, {"id": "1", "answer": "De două tipuri: decizionale și repetitive"}, {"id": "2", "answer": "Mecanisme prin care putem controla execuția programului nostru"}, {"id": "3", "answer": "Sistem de verificare a corectitudinii programelor"}], "explanation": "Structurile de control ne permit să construim secvențe complexe de instrucțiuni. Aceste construcții pot fi executate în funcție de anumite condiții (<strong>decizionale</strong>) sau de un număr de ori (<strong>repetitive</strong>) și totodată le putem combina pe ambele."}, "1": {"statement": "Secvență **if-else** de mai jos poate fi modificată folosind operatorul ternar astfel:\n<pre><code>let numar  = prompt('Introdu un număr')\nif (numar >= 0) \n    return \"Număr pozitiv\"\nelse \n    return \"Număr negativ\"</pre></code>", "correct": [0, 1, 3], "answers": [{"id": "0", "answer": "<pre><code>return numar >= 0 ? \"Număr pozitiv\" : \"Număr negativ\"</pre></code>"}, {"id": "1", "answer": "<pre><code>return \"Număr\" + (numar >= 0 ? \"pozitiv\" : \"negativ\")</pre></code>"}, {"id": "2", "answer": "<pre><code>return \"Număr pozitiv\" if numar >= 0 else \"Număr negativ\"</pre></code>"}, {"id": "3", "answer": "<pre><code>numar >= 0 ? return \"Număr pozitiv\" : return \"Număr negativ\"</pre></code>"}]}, "2": {"statement": "Operatorul ternar este singurul operator care necesită trei operanzi.", "correct": [0], "answers": [{"id": "0", "answer": "Adevărat"}, {"id": "1", "answer": "Fals"}]}, "3": {"statement": "Folosim structura <strong>for</strong>:", "correct": [0, 2], "answers": [{"id": "0", "answer": "Când vrei să repetăm o instrucțiune de un număr de ori"}, {"id": "1", "answer": "Când vrem să sărim peste anumite instrucțiuni"}, {"id": "2", "answer": "Când vrem să parcurgem un vector"}, {"id": "3", "answer": "Când vrem să executăm înapoi instrucțiuni din programul nostru."}]}, "4": {"statement": "Ce putem afirma despre structurile <strong>for</strong> și <strong>while</strong>:", "correct": [0, 1], "answers": [{"id": "0", "answer": "Sunt echivalente ca funcționalitate"}, {"id": "1", "answer": "In general folosim <em>for</em> când știm exact numărul de pași de repetat iar <em>while</em> când nu îi știm dar îi vom determina în timpul rulării programului"}, {"id": "2", "answer": "<em>for</em> necesită inițializarea contorului de repetiții iar while nu"}, {"id": "3", "answer": "Cu <em>for</em> putem doar incrementa contorul de repetiție însă cu <em>while</em> putem aduna orice valoare"}], "explanation": "Atât <em>for</em> cât și <em>while</em> sunt structuri repetitive ce se bazează pe o condiție pentru a finaliza repetiția. În general, structura <em>for</em> este folosită când numărul de pași de executat este cunoscut iar <em>while</em> în caz contrar. Cu alte cuvinte, vom folosi o structură <em>for</em> când numărul de iterații este cunoscut din momentul scrierii codului iar <em>while</em> când numărul de iterații se va determina dinamic în timpul rulării programului în funcție de alte condiții."}, "5": {"statement": "Instrucțiunea <strong>break</strong>:", "correct": [1], "answers": [{"id": "0", "answer": "Întrerupe complet programul"}, {"id": "1", "answer": "Întrerupe bucla for, while, do-while sau switch în care a fost specificat"}, {"id": "2", "answer": "Întoarce execuția programului la începutul buclei pe care a întrerupt-o"}, {"id": "3", "answer": "Este folosită doar în structurile switch"}]}, "6": {"statement": "Instrucțiunea <strong>continue</strong>:", "correct": [1, 2, 3], "answers": [{"id": "0", "answer": "Trece la următorul program"}, {"id": "1", "answer": "Sare peste restul instrucțiunilor aflate după el într-o structură repetitiva trecând la o nouă iterație"}, {"id": "2", "answer": "Permite evitarea executării corpului unui bloc repetitiv în funcție de anumite criterii"}, {"id": "3", "answer": "Poate fi înlocuit cu o structură if"}], "explanation": "Instrucțiunea <em>continue</em> indică unei structuri repetitive că poate renunța la a mai executa instrucțiunile aflate după instrucțiunea continue și trece la următorul pas din iterație. Este util atunci când în funcție de o anumită condiție decidem că restul instrucțiunilor dintr-o structură repetitiva nu mai sunt necesar de executat. Ne putem imagina cum acest mecanism poate fi înlocuit ușor și de o structura <em>if</em>."}, "7": {"statement": "Structura <strong>switch</strong>:", "correct": [0, 1, 2], "answers": [{"id": "0", "answer": "Este o structură similară celei <strong>if-else-if</strong>"}, {"id": "1", "answer": "Folosește instrucțiunea <strong>break</strong> în ramurile pentru care s-a găsit egalitatea pentru a evita executare restului ramurilor sale"}, {"id": "2", "answer": "Poate agrega mai multe clauze <strong>case</strong> unui singur set de instrucțiuni"}, {"id": "3", "answer": "Necesită doar expresii constante în clauzele <strong>case</strong>"}]}, "8": {"statement": "Nefolosirea cuvântului cheie <strong>break</strong> într-o ramură a structurii <strong>switch</strong>:", "correct": [0], "answers": [{"id": "0", "answer": "Determină executarea tuturor ramurilor ce urmează după ea"}, {"id": "1", "answer": "Nu are niciun efect"}, {"id": "2", "answer": "Determina și executarea ramurii <strong>default</strong>"}], "explanation": "Un comportament oarecum ciudat al structurii <em>switch</em> este că după intrarea într-o clauză <em>case</em> dacă nu întâlnește instrucțiunea <em>break</em> atunci vă executa toate clauzele <em>case</em> următoare. Din aceasta cauză este important ca fiecare clauză <em>case</em> să conțină instrucțiunea <em>break</em>."}}, "src-ro": "structuri-control.ro.quiz"}