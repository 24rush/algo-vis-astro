{"ro": [{"id": 0, "statement": "Structurile de control sunt:", "answers": [{"answer": "Cuvinte cheie rezervate limbajului de programare care ne permit să efectuăm operații decizionale și repetitive în cod", "correct": true}, {"answer": "De două tipuri: decizionale și repetitive", "correct": true}, {"answer": "Mecanisme prin care putem controla execuția programului nostru", "correct": true}, {"answer": "Sistem de verificare a corectitudinii programelor"}], "explanation": "Structurile de control ne permit să construim secvențe complexe de instrucțiuni. Aceste construcții pot fi executate în funcție de anumite condiții (<strong>decizionale</strong>) sau de un număr de ori (<strong>repetitive</strong>) și totodată le putem combina pe ambele."}, {"id": 1, "statement": "Secvență **if-else** de mai jos poate fi modificată folosind operatorul ternar astfel:\n<pre><code>let numar  = prompt('Introdu un număr')\nif (numar >= 0) \n    return \"Număr pozitiv\"\nelse \n    return \"Număr negativ\"</pre></code>", "answers": [{"answer": "<pre><code>return numar >= 0 ? \"Număr pozitiv\" : \"Număr negativ\"</pre></code>", "correct": true}, {"answer": "<pre><code>return \"Număr\" + (numar >= 0 ? \"pozitiv\" : \"negativ\")</pre></code>", "correct": true}, {"answer": "<pre><code>return \"Număr pozitiv\" if numar >= 0 else \"Număr negativ\"</pre></code>"}, {"answer": "<pre><code>numar >= 0 ? return \"Număr pozitiv\" : return \"Număr negativ\"</pre></code>", "correct": true}]}, {"id": 2, "statement": "Operatorul ternar este singurul operator care necesită trei operanzi.", "answers": [{"answer": "Adevărat", "correct": true}, {"answer": "Fals"}]}, {"id": 3, "statement": "Folosim structura <strong>for</strong>:", "answers": [{"answer": "Când vrei să repetăm o instrucțiune de un număr de ori", "correct": true}, {"answer": "Când vrem să sărim peste anumite instrucțiuni"}, {"answer": "Când vrem să parcurgem un vector", "correct": true}, {"answer": "Când vrem să executăm înapoi instrucțiuni din programul nostru."}]}, {"id": 4, "statement": "Ce putem afirma despre structurile <strong>for</strong> și <strong>while</strong>:", "answers": [{"answer": "Sunt echivalente ca funcționalitate", "correct": true}, {"answer": "In general folosim <em>for</em> când știm exact numărul de pași de repetat iar <em>while</em> când nu îi știm dar îi vom determina în timpul rulării programului", "correct": true}, {"answer": "<em>for</em> necesită inițializarea contorului de repetiții iar while nu"}, {"answer": "Cu <em>for</em> putem doar incrementa contorul de repetiție însă cu <em>while</em> putem aduna orice valoare"}], "explanation": "Atât <em>for</em> cât și <em>while</em> sunt structuri repetitive ce se bazează pe o condiție pentru a finaliza repetiția. În general, structura <em>for</em> este folosită când numărul de pași de executat este cunoscut iar <em>while</em> în caz contrar. Cu alte cuvinte, vom folosi o structură <em>for</em> când numărul de iterații este cunoscut din momentul scrierii codului iar <em>while</em> când numărul de iterații se va determina dinamic în timpul rulării programului în funcție de alte condiții."}, {"id": 5, "statement": "Instrucțiunea <strong>break</strong>:", "answers": [{"answer": "Întrerupe complet programul"}, {"answer": "Întrerupe bucla for, while, do-while sau switch în care a fost specificat", "correct": true}, {"answer": "Întoarce execuția programului la începutul buclei pe care a întrerupt-o"}, {"answer": "Este folosită doar în structurile switch"}]}, {"id": 6, "statement": "Instrucțiunea <strong>continue</strong>:", "answers": [{"answer": "Trece la următorul program"}, {"answer": "Sare peste restul instrucțiunilor aflate după el într-o structură repetitiva trecând la o nouă iterație", "correct": true}, {"answer": "Permite evitarea executării corpului unui bloc repetitiv în funcție de anumite criterii", "correct": true}, {"answer": "Poate fi înlocuit cu o structură if", "correct": true}], "explanation": "Instrucțiunea <em>continue</em> indică unei structuri repetitive că poate renunța la a mai executa instrucțiunile aflate după instrucțiunea continue și trece la următorul pas din iterație. Este util atunci când în funcție de o anumită condiție decidem că restul instrucțiunilor dintr-o structură repetitiva nu mai sunt necesar de executat. Ne putem imagina cum acest mecanism poate fi înlocuit ușor și de o structura <em>if</em>."}, {"id": 7, "statement": "Structura <strong>switch</strong>:", "answers": [{"answer": "Este o structură similară celei <strong>if-else-if</strong>", "correct": true}, {"answer": "Folosește instrucțiunea <strong>break</strong> în ramurile pentru care s-a găsit egalitatea pentru a evita executare restului ramurilor sale", "correct": true}, {"answer": "Poate agrega mai multe clauze <strong>case</strong> unui singur set de instrucțiuni", "correct": true}, {"answer": "Necesită doar expresii constante în clauzele <strong>case</strong>"}]}, {"id": 8, "statement": "Nefolosirea cuvântului cheie <strong>break</strong> într-o ramură a structurii <strong>switch</strong>:", "answers": [{"answer": "Determină executarea tuturor ramurilor ce urmează după ea", "correct": true}, {"answer": "Nu are niciun efect"}, {"answer": "Determina și executarea ramurii <strong>default</strong>"}], "explanation": "Un comportament oarecum ciudat al structurii <em>switch</em> este că după intrarea într-o clauză <em>case</em> dacă nu întâlnește instrucțiunea <em>break</em> atunci vă executa toate clauzele <em>case</em> următoare. Din aceasta cauză este important ca fiecare clauză <em>case</em> să conțină instrucțiunea <em>break</em>."}], "src-ro": "structuri-control.ro.quiz"}