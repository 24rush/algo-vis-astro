{"ro": [{"desc": "caracter $", "id": "0", "code": "// se citeste textul de la utilizator\n\n// se declara o noua variabila text ce va contine textul generat dupa aplicarea regulii\n\n// se parcurge textul initial caracater cu caracater\n\n    // daca caracaterul de la pozitia curenta nu este cel special $ atunci il adaugam in textul generat\n\n        // daca caracterul este cel special atunci stergem din textul generat ultimul caracater folosind substring\n\n// se afiseaza textul rezultat", "solution": "// se citeste textul de la utilizator\nlet str = \"Anc$a are$de fan\"\n\n// se declara o noua variabila text ce va contine textul generat dupa aplicarea regulii\nlet corect = \"\";\n\n// se parcurge textul initial caracater cu caracater\nfor (let currIndex = 0; currIndex < str.length; currIndex++) {\n    // daca caracaterul de la pozitia curenta nu este cel special $ atunci il adaugam in textul generat\n    if (str.charAt(currIndex) != '$')\n        corect += str.charAt(currIndex);\n    else {\n        // daca caracterul este cel special atunci stergem din textul generat ultimul caracater folosind substring\n        if (corect.length)\n            corect = corect.substring(0, corect.length - 1)\n  }\n}\n\n// se afiseaza textul rezultat\nconsole.log(corect)"}, {"desc": "anagrame", "id": "1", "code": "// se citeste textul de la utilizator\n\n// se declara o variabila text ce contine textul 'target' (apollo)\n\n// daca lungimea celor doua text nu este egala atunci clar nu se poate obtine\n\n    // in caz contrar, parcurgem textul introdus de utilizator, caracater cu caracater\n\n        // cautam caracaterul curent in textul target (apollo)\n\n        // daca acesta exista\n\n            // il stergem din textul target folosind slice(0, index) + slice(index+1)\n            // astfel l-am marcat ca fiind gasit\n\n    // afisam mesajul corespunzator in functie de lungimea ramasa in textul target", "solution": "// se citeste textul de la utilizator\nlet str = prompt('Text=')\n\n// se declara o variabila text ce contine textul 'target' (apollo)\nlet targetStr = \"apollo\"\n\n// daca lungimea celor doua text nu este egala atunci clar nu se poate obtine\nif (str.length != targetStr.length) {\n    console.log('Nu se poate obtine')\n}\nelse {\n    // in caz contrar, parcurgem textul introdus de utilizator, caracater cu caracater\n    for (let indexStr = 0; indexStr < str.length; indexStr++) {\n        // cautam caracaterul curent in textul target (apollo)\n        let indexTarget = targetStr.indexOf(str.charAt(indexStr));\n\n        // daca acesta exista\n        if (indexTarget != -1) {\n            // il stergem din textul target folosind slice(0, index) + slice(index+1)\n            // astfel l-am marcat ca fiind gasit\n            targetStr = targetStr.slice(0, indexTarget) + targetStr.slice(indexTarget + 1);\n        }\n    }\n\n    // afisam mesajul corespunzator in functie de lungimea ramasa in textul target\n    if (targetStr.length == 0) {\n        console.log('Se poate obtine')\n    } else console.log('Nu se poate obtine')\n}"}, {"desc": "dublare", "id": "2", "code": "// se citeste textul de la utilizator\n\n// se declara o variabila noua ce va contine textul generat\n\n// se 'sparge' textul introdus in cuvinte folosind functia split\n\n// se parcuge lista de cuvinte \n\n    // se testeaza daca cuvantul curent nu este 'si'\n    \n        // se adauga in textul generat prin concatenarea sa cu el insusi plus un spatiu\n\n// se afiseaza textul generat", "solution": "// se citeste textul de la utilizator\nlet str = prompt('Text=');\n\n// se declara o variabila noua ce va contine textul generat\nlet textNou = \"\";\n\n// se 'sparge' textul introdus in cuvinte folosind functia split\nlet cuvinte = str.split(' ');\n\n// se parcuge lista de cuvinte \nfor (let indexCuv = 0; indexCuv < cuvinte.length; indexCuv++) {\n    // se testeaza daca cuvantul curent nu este 'si'\n    if (cuvinte[indexCuv] != 'si')\n        // se adauga in textul generat prin concatenarea sa cu el insusi plus un spatiu\n        textNou += cuvinte[indexCuv] + ' ' + cuvinte[indexCuv] + ' ';\n}\n\n// se afiseaza textul generat\nconsole.log(textNou)"}, {"desc": "cifre in text", "id": "4", "code": "// se citeste textul de la utilizator\n\n// se declara o variabila noua ce va stoca suma numerelor gasite\n\n// se 'sparge' in cuvinte folosind functia split\n\n// se parcurg cuvintele din text\n\n    // se incearca sa se converteasca la intreg cuvantul curent folosind parseInt\n\n    // daca conversia nu a generat un NaN atunci se aduna la suma\n    // functia isNan(numar) ne indica daca numar-ul este intr-adevar numar sau Nan\n\n// se afiseaza suma determinata", "solution": "// se citeste textul de la utilizator\nlet str = prompt('Text=');\n\n// se declara o variabila noua ce va stoca suma numerelor gasite\nlet suma = 0;\n\n// se 'sparge' in cuvinte folosind functia split\nlet cuvinte = str.split(' ');\n\n// se parcurg cuvintele din text\nfor (let indexCuv = 0; indexCuv < cuvinte.length; indexCuv++) {\n    // se incearca sa se converteasca la intreg cuvantul curent folosind parseInt\n    let nr = parseInt(cuvinte[indexCuv]);\n\n    // daca conversia nu a generat un NaN atunci se aduna la suma\n    // functia isNan(numar) ne indica daca numar-ul este intr-adevar numar sau Nan\n    if (!isNaN(nr)) \n        suma += nr;\n}\n\n// se afiseaza suma determinata\nconsole.log(suma)"}, {"desc": "aparitii 5", "id": "5", "code": "// se citeste textul de la utilizator\n\n// se declara o variabila ce va contine numarul de aparitii ale caracaterul 5\n\n// se cauta prima aparitie a caracaterului 5 folosind indexOf\n\n// cat timp gasim caracterul '5' adica indexul returna de indexOf nu este -1\n\n    // incrementam variabila numarului de aparitii\n\n    // cautam urmatoarea aparitie folosind tot indexOf insa specificand pozitia de la care sa inceapa cautarea\n    // adica de la ultimul index gasit + 1\n\n// afisam numarul de aparitii", "solution": "// se citeste textul de la utilizator\nlet str = prompt('Text=');\n\n// se declara o variabila ce va contine numarul de aparitii ale caracaterul 5\nlet countFive = 0;\n\n// se cauta prima aparitie a caracaterului 5 folosind indexOf\nlet indexOfFive = str.indexOf('5');\n\n// cat timp gasim caracterul '5' adica indexul returna de indexOf nu este -1\nwhile (indexOfFive != -1) {\n    // incrementam variabila numarului de aparitii\n    countFive += 1;\n\n    // cautam urmatoarea aparitie folosind tot indexOf insa specificand pozitia de la care sa inceapa cautarea\n    // adica de la ultimul index gasit + 1\n    indexOfFive = str.indexOf('5', indexOfFive + 1)    \n}\n\n// afisam numarul de aparitii\nconsole.log(countFive)"}, {"desc": "ecou", "id": "6", "code": "// se citeste textul de la utilizator\n\n// se 'sparge' in cuvinte folosind functia split\n\n// se parcurge fiecare cuvant din lista rezultata\n\n    // se declara o variabila contor pentru indexul literelor din cuvantul curent\n\n    // se parcurge cuvantul curent litera cu litera comparent pozitiile adiacente\n    // asta inseamna ca va trebui sa parcurgem doar pana la penultima pozitie\n\n        // daca doua caractere adiacente sunt diferite atunci parasim bucla pentru ca este clar \n        // ca nu avem aceeasi litera in cuvantul curent\n\n    // daca am ajuns cu indexul literelor la penultima pozitie inseamna ca am avut egalitate pentru \n    // toate pozitiile adiacente asa ca putem afisa cuvantul curent", "solution": "// se citeste textul de la utilizator\nlet str = prompt('Text=');\n\n// se 'sparge' in cuvinte folosind functia split\nlet cuvinte = str.split(' ');\n\n// se parcurge fiecare cuvant din lista rezultata\nfor (let indexCuv = 0; indexCuv < cuvinte.length; indexCuv++) {\n    // se declara o variabila contor pentru indexul literelor din cuvantul curent\n    let indexLitera = 0;\n\n    // se parcurge cuvantul curent litera cu litera comparent pozitiile adiacente\n    // asta inseamna ca va trebui sa parcurgem doar pana la penultima pozitie\n    while (indexLitera < cuvinte[indexCuv].length - 1) {\n        // daca doua caractere adiacente sunt diferite atunci parasim bucla pentru ca este clar \n        // ca nu avem aceeasi litera in cuvantul curent\n        if (cuvinte[indexCuv].charAt(indexLitera) != cuvinte[indexCuv].charAt(indexLitera + 1)) {\n            break;\n        }\n\n        indexLitera++;\n    }\n\n    // daca am ajuns cu indexul literelor la penultima pozitie inseamna ca am avut egalitate pentru \n    // toate pozitiile adiacente asa ca putem afisa cuvantul curent\n    if (indexLitera == cuvinte[indexCuv].length - 1) \n        console.log(cuvinte[indexCuv])\n}"}], "src-ro": "stringuri.ro.snip"}