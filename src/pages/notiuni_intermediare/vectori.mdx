---
title: "Vectori"
layout: "../../layouts/MainLayout.astro"
---

import Box from '../../components/Content/Box.astro'
import Arrow from '../../components/Content/Arrow.astro'
import Check from '../../components/Content/Check.astro'
import ClickAv from '../../components/Content/ClickAv.astro'
import Algovis from '../../components/Content/Algovis.astro';
import P5Widget from "../../components/P5Widget.astro";
import YTVideo from '../../components/Content/YTVideo.astro'

<Box knowledge>
<strong>Ce vom descoperi în acest articol:</strong>
<br/><Check/>ce reprezintă tipul vector / array
<br/><Check/>la ce ne ajută acest tip de date
<br/><Check/>ce operații sunt disponibile asupra variabilelor de tip array
</Box>

<h0>Vectori</h0>

Un tip de obiect foarte des utilizat în programele Javascript este **array** (vector sau listă) ce poate stoca o colecție ordonată de valori de orice tip. Elementele sale sunt stocate în ordinea introducerii lor în colecție și pot fi accesate folosind poziția lor din colecție.

<YTVideo video_id="gUOwZkL09BE" title="Intro to Arrays | Khan Academy" caption="Urmărește video-ul următor ca să afli mai multe despre vectori"/>

# Caracteristici #
Acest tip este definit de o lungime și de posibilitatea de a accesa orice element al său specificând poziția pe care ne-o dorim folosind parantezele pătrate (```[ ]```) între care vom specifica această poziție.

<img src="../assets/imgs/vectori0.png" class="img-box" />

<Box attention>Ca în multe alte limbaje de programare, pozițiile într-un vector încep de la <strong>0</strong> și nu de la <strong>1</strong>. Asta înseamnă că primul element se vă găsi la poziția 0 adică <code>v1[0]</code> și nu <code>v1[1]</code>.</Box>

<ClickAv>Rulează exemplu pentru a crea primul tău vector</ClickAv>
<Algovis>
```js
let vector = [1, 2, 3, 4];
console.log(vector[0]);
console.log(vector[1]);
```
</Algovis>

# Iterare #
De foarte multe ori, un program va avea nevoie să știe câte elemente se află într-o variabilă de tip vector iar pentru asta vom folosi proprietatea <code>length</code>. Cea mai uzuală construcție ce are nevoie să știe lungimea vectorului este cea de parcurgere adică vizitare a fiecărui element.

<ClickAv>Rulează exemplul și observă cum se derulează parcurgerea</ClickAv>
<Algovis>
```js
let vector = ["A", "B", "C"];
for (let i = 0; i < vector.length; i++) {
    console.log(vector[i]);
}
```
</Algovis>

## for-of / for-in ##
O variantă alternativă la structura for clasică în care iterăm folosind un contor este **for-of**. Această construcție ne permite să extragem direct valorile colecției într-o variabilă pe care apoi să o utilizăm în corpul blocului for. 

<ClickAv>Exemplul de mai sus rescris folosind for-of:</ClickAv>
<Algovis>
```js
let vector = ["A", "B", "C"];
for (let value of vector) {
  console.log(value);
}
```
</Algovis>

<ClickAv>Varianta **for-in** este similară celei for-of, diferența fiind că aceasta ne va întoarce în variabila indexul elementului și nu valoarea sa.</ClickAv>
<Algovis>
```js
let vector = ["A", "B", "C"];
for (let index in vector) {
  console.log(index);
}
```
</Algovis>

<P5Widget>
```
let circleY = [50, 100, 150, 200, 250];
let speeds = [1, 3, 2, 6, 2, 6, 4, 22, 3, 40];

function setup() {  
  createCanvas(300, 300);
  stroke(255);
}

function draw() {
  background(200,20,36);

  for (let i = 0; i < circleY.length; i++) {
    circle(50 * (i + 1), circleY[i], 25);

    circleY[i] += random(speeds);
    
    if (circleY[i] > height) {
      circleY[i] = 0;
    }
  }
}
```
</P5Widget>

# Manipulare vectori #
Pe lângă proprietatea <code>length</code>, variabilele de tip vector ne pun la dispoziție o multitudine de funcții (metode) prin care putem să manipulăm mai ușor conținutul lor. Vom evidenția doar câteva din ele mai jos:

<Arrow/> ```push``` - cea mai utilizată metodă a vectorilor prin care putem adăuga un element nou colecției, la sfârșitul acesteia

<Arrow/> ```pop``` - similar funcției push doar că această metodă va elimina ultimul element al colecției

<Arrow/> ```shift``` - similar funcției pop doar că această funcție va elimina primul element al colecției

<Arrow/> ```unshift(element1, element2, ...)``` - similar funcției push doar că această funcție va adăuga elementele primite ca parametrii la începutul colecției

<Arrow/> ```concat``` - ne permite să alăturam două colecții într-una nouă (ce le va conține pe ambele)

<Arrow/> <code>slice(startIndex, endIndex)</code> - ne permite să extragem din vector porțiunea delimitată de pozițiile <code>startIndex</code> și <code>endIndex</code>

<Arrow/> <code>splice(startIndex, numarStergeri)</code> - ne permite să stergem din vector începând cu poziția <code>startIndex</code> un numar de elemente egal cu <code>numarStergeri</code> iar dacă nu menționăm acest parametru va șterge până la sfârșitul vectorului

<Arrow/> ```reverse``` - după cum numele indică, această metodă va ordona elementele dintr-o colecție în ordinea inversă celei curente

<Arrow/> ```indexOf(element)``` - ne ajută să căutam un element într-o colecție întorcând prima poziție la care a fost întâlnit

<ClickAv>Rulează pentru a observa cum funcționează metodele de mai sus:</ClickAv>
<Algovis>
```js
let vectorA = [1, 2, 3, 4];
let vectorB = [11, 12, 13, 14, 15];

console.log('Lungimea vectorului A este: ' + vectorA.length);

vectorA.push(5); /*** Adaugăm o valoare nouă la sfârșitul colecției ***/
console.log('Lungimea vectorului A este acum: ' + vectorA.length);

vectorA[0] = 7; /*** Modificăm o valoare existentă ***/
console.log(vectorA);

let vectorC = vectorA.concat(vectorB);
console.log('Lungimea vectorului C este: ' + vectorC.length);

let ultimulElement = vectorC.pop();
console.log('Ultimul element din vectorC a fost: ' + ultimulElement);

let sectiune = vectorC.slice(0, 3); /*** Extragem elementele dintre indexul 0 si 3 ***/
console.log(sectiune);

let reverse = vectorC.reverse();
console.log(reverse);

console.log('Poziția elementului 2 este: ' + reverse.indexOf(2));
```
</Algovis>

<Box attention>
Când utilizăm funcțiile de manipulare a vectorilor trebuie să avem în vedere dacă funcția <strong>modifică</strong> sau nu continutul vectorului pe care este aplicată.

Anumite funcții sunt implementate de limbajul Javascript să lase nemodificat vectorul pe care sunt aplicate și în schimb să <strong>întoarcă un alt vector</strong> cu modificările prin valoarea de retur a funcției. 

De ex., funcția <code>reverse</code> modifică vectorul pe care este aplicată în schimb funcția <code>slice</code> va lăsa vectorul nemodificat dar va întoarce conținutul solicitat prin valoare de retur.
</Box>

## Stergere element ##
Pentru a șterge un element dintr-un vector, va trebui să folosim funcțiile <code>indexOf</code> pentru a identifica poziția pe care se află elementul apoi <code>splice</code> pentru a șterge efectiv elementul din vector.

<ClickAv>Rulează pentru a șterge un element din vector</ClickAv>
<Algovis>
```js
let x = [1, -12, 3, 5, 2]

let poz = x.indexOf(2); /*** Căutam poziția elementului cu valoarea 2 ***/

if (poz != -1) { /*** Dacă am găsit cu element cu valoarea 2 ***/
    x.splice(poz, 1); /*** Ștergem un element începând cu poziția pe care l-am găsit ***/
}
```
</Algovis>

<YTVideo video_id="CrIyQhB__pE" title="Modifying Arrays | Khan Academy" caption="Urmărește video-ul următor ca să afli mai multe despre cum poți modifica un vector"/>

# Vectori multidimensionali 
Vectorii multidimensionali, cunoscuți și sub numele de **matrice** sau tablouri multidimensionale, sunt structuri de date care pot stoca elemente în mai mult de o dimensiune. 

În JavaScript, acestea pot fi implementate utilizând vectori imbricați (vectori de vectori), permițând astfel stocarea de date într-o formă bidimensională sau chiar tridimensională.

<ClickAv>Rulează exemplul și crează prima ta matrice</ClickAv>
<Algovis>
```js
let matrice = [
  [12, 1, 4, 6], 
  [7, 10, 0, 20],   
  [1, 6, 10, 9]
];

console.log('matrice creata');
```
</Algovis>

Dimensiunea matricei de mai sus este de 3 rânduri și 4 coloane și putem accesa conținutul ei la fel ca și în cazul unui vector, folosind poziții ce încep de la 0. Singura diferență va fi că acum va trebui să folosim ``` [] ``` pentru fiecare dimensiune pe care dorim să o accesăm. 

Primul set de paranteze pătrate va accesa **liniile (rândurile)** matricei iar cel de-al doilea set va accesa **coloanele**.

<Algovis>
```js
let matrice = [
  [12, 1, 4, 6], 
  [7, 10, 0, 20],   
  [1, 6, 10, 9]
];

// Afiseaza primul rand
console.log(matrice[0]);

// Afiseaza primul element din randul al doilea
console.log(matrice[1][0]);
```
</Algovis>

## Iterarea unei matrice
Similar tablourilor unidimensionale (vectorilor), parcurgerea se va face folosind o buclă *for* însă având în vedere că acum tabloul are două dimensiuni, va trebui să mai introducem încă una pentru această a doua dimensiune.

<Algovis>
```js
let matrice = [
  [12, 1, 4, 6], 
  [7, 10, 0, 20],   
  [1, 6, 10, 9]
];

for (let i = 0; i < matrice.length; i++) {
    console.log('Randul ' + i + ':');
    for (let j = 0; j < matrice[i].length; j++) {
        console.log(matrice[i][j]);
    }
}
```
</Algovis>

<Box attention>
<strong>Rezumat:</strong>
<br/><Arrow/>Tipul de date vector ne permite să stocăm o <strong>colecție de valori</strong>
<br/><Arrow/>Accesarea (scrierea sau citirea) elementelor se face folosind poziția lor în vector
<br/><Arrow/><strong>Pozițiile în vectori încep de la 0</strong>
<br/><Arrow/>Un vector este definit de lungimea sa (câte elemente conține)
</Box>